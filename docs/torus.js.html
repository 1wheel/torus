<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>torus.js annotated source</title>
    <link rel="stylesheet" href="main.css">
</head>

<body>
    <main>
        <div class="line">
            <div class="doc">
                <h1>torus.js <span class="fade">annotated source</span></h1>
                <em><a class="back" href="./">Back to index</a></em>
            </div>
            <pre></pre>
        </div>
        <div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1</strong>// @begindebug</pre></div>
<div class="line"><div class="doc"><p>These utility functions enable rich debugging statements during development, when using the development build (<code>dist/torus.dev.js</code>). These give you hierarchical information about what components are being rendered, and how.</p>
</div><pre class="source javascript"><strong class="lineNumber">6</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>Flag to enable rich debugging during renders</p>
</div><pre class="source javascript"><strong class="lineNumber">8</strong>const DEBUG_RENDER = true;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">9</strong></pre></div>
<div class="line"><div class="doc"><p>Repeat a string <code>count</code> times. Used to indent in <code>render_debug</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">11</strong>const repeat = (str, count) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">12</strong>    let s = '';</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">13</strong>    while (count -- &#62; 0) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">14</strong>        s += str;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">15</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">16</strong>    return s;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">17</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">18</strong></pre></div>
<div class="line"><div class="doc"><p>Main rich debug logger function. <code>render_debug()</code> depends on the <code>render_stack</code> counter in our rendering algorithm to figure out how deep in the render tree we are, and indent the message to the level appropriate to our place in the render tree.</p>
</div><pre class="source javascript"><strong class="lineNumber">24</strong>const render_debug = (msg, header = false) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">25</strong>    if (DEBUG_RENDER) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">26</strong>        if (header) {</pre></div>
<div class="line"><div class="doc"><p>We want to pull forward headers in front of their section contents, so we de-indent 1.</p>
</div><pre class="source javascript"><strong class="lineNumber">29</strong>            const prefix = repeat('\t', render_stack - 1);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">30</strong>            console.log('%c' + prefix + msg, 'font-weight: bold');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">31</strong>        } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">32</strong>            const prefix = repeat('\t', render_stack);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">33</strong>            console.log(prefix + msg);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">34</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">35</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">36</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">37</strong>// @enddebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">38</strong></pre></div>
<div class="line"><div class="doc"><p>IDL attributes are attributes that are reflected in <code>HTMLElement</code> objects&#39; JavaScript properties. They&#39;re often boolean flags, so they&#39;re easier to set (and sometimes only possible to set) in JS as opposed to using <code>HTMLElement.setAttribute()</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">43</strong>const HTML_IDL_ATTRIBUTES = [</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">44</strong>    'type',</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">45</strong>    'value',</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">46</strong>    'selected',</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">47</strong>    'indeterminate',</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">48</strong>    'tabIndex',</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">49</strong>    'checked',</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">50</strong>    'disabled',</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">51</strong>];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">52</strong></pre></div>
<div class="line"><div class="doc"><p>A global counter for how deep we are in our render tree. 0 indicates that we aren&#39;t in the middle of rendering.</p>
</div><pre class="source javascript"><strong class="lineNumber">55</strong>let render_stack = 0;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">56</strong></pre></div>
<div class="line"><div class="doc"><p>Shortcut utility function to check if a given name is bound to something that&#39;s an actual object (not just null). We perform the <code>null</code> check first because that&#39;s faster.</p>
</div><pre class="source javascript"><strong class="lineNumber">60</strong>const isObject = obj =&#62; obj !== null &#38;&#38; typeof obj === 'object';</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">61</strong></pre></div>
<div class="line"><div class="doc"><p><code>normalizeJDOM</code> takes a JDOM object (dictionary) and modifies it in place so it has the default JDOM properties, and we don&#39;t have to complicate our rendering code by checking for nulls with every key access into our serialized virtual DOM. Note that we don&#39;t check <code>isObject(jdom)</code> here. We assume only valid objects are passed in to &#39;normalize&#39;, which is true in our usage so far. <code>normalizeJDOM</code> is a hot path in rendering, so we need it as fast as it can be.</p>
</div><pre class="source javascript"><strong class="lineNumber">70</strong>const normalizeJDOM = jdom =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">71</strong>    jdom.attrs = jdom.attrs || {};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">72</strong>    jdom.events = jdom.events || {};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">73</strong>    jdom.children = jdom.children || [];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">74</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">75</strong></pre></div>
<div class="line"><div class="doc"><p>Quick shorthand to normalize either 1. a single value or 2. an array of values into an array of values. This is useful because JDOM accepts either into things like <code>attrs.class</code> and <code>events.&lt;name&gt;</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">79</strong>const arrayNormalize = data =&#62; Array.isArray(data) ? data : [data];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">80</strong></pre></div>
<div class="line"><div class="doc"><p>We use comment nodes as placeholder nodes because they&#39;re lightweight and invisible.</p>
</div><pre class="source javascript"><strong class="lineNumber">83</strong>const tmpNode = () =&#62; document.createComment('');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">84</strong></pre></div>
<div class="line"><div class="doc"><p><code>opQueue</code> is a global queue of node-level operations to be performed. These are calculated during the diff, but because operations touching the page DOM are expensive, we defer them until the end of a render pass and run them all at once, asynchronously. Each item in the queue is an array that starts with an opcode (one of the three below), and is followed by the list of arguments the operation takes. We render all operations in the queue to the DOM before the browser renders the next frame.</p>
</div><pre class="source javascript"><strong class="lineNumber">92</strong>let opQueue = [];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">93</strong>const OP_APPEND = 0; // append, parent, new</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">94</strong>const OP_REMOVE = 1; // remove, parent, old</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">95</strong>const OP_REPLACE = 2; // replace, old, new</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">96</strong></pre></div>
<div class="line"><div class="doc"><p><code>runDOMOperations</code> works through the <code>opQueue</code> and performs each DOM operation in order they were queued. rDO is called when the reconciler (<code>renderJDOM</code>) reaches the bottom of a render stack (when it&#39;s done reconciling the diffs in a root-level JDOM node of a component).</p>
</div><pre class="source javascript"><strong class="lineNumber">101</strong>function runDOMOperations() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>This function is written to avoid any potential reconciliation conflicts. There are two risks to mitigate: 1. attempting insert a node that is already in the DOM, and 2. attempting remove a node that isn&#39;t in the DOM. Both will result in inconsistent DOM state and break the renderer. To avoid this, first, we remove all children and add placeholders where they ought to be replaced. Then, in a second loop, we add any children that need to be added and replace placeholders. Thus, no children will be inadvertently removed and no wrong node will be removed.</p>
</div><pre class="source javascript"><strong class="lineNumber">110</strong>    const len = opQueue.length;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">111</strong>    for (let i = 0; i &#60; len; i ++) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">112</strong>        const next = opQueue[i];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">113</strong>        const op = next[0];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">114</strong>        if (op === OP_REMOVE) {</pre></div>
<div class="line"><div class="doc"><p>Remove all children that should be</p>
</div><pre class="source javascript"><strong class="lineNumber">116</strong>            next[1].removeChild(next[2]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">117</strong>        } else if (op === OP_REPLACE) {</pre></div>
<div class="line"><div class="doc"><p>For the ones queued to for being replaced, put in a placeholder node, and queue that up instead.</p>
</div><pre class="source javascript"><strong class="lineNumber">120</strong>            const oldNode = next[1];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">121</strong>            const tmp = tmpNode();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">122</strong>            const parent = oldNode.parentNode;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">123</strong>            parent.replaceChild(tmp, oldNode);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">124</strong>            next[1] = tmp;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">125</strong>            next[3] = parent;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">126</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">127</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">128</strong>    for (let i = 0; i &#60; len; i ++) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">129</strong>        const next = opQueue[i];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">130</strong>        const op = next[0];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">131</strong>        if (op === OP_APPEND) {</pre></div>
<div class="line"><div class="doc"><p>Add any node that need to be added</p>
</div><pre class="source javascript"><strong class="lineNumber">133</strong>            next[1].appendChild(next[2]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">134</strong>        } else if (op === OP_REPLACE) {</pre></div>
<div class="line"><div class="doc"><p>Replace placeholders with correct nodes. This is equivalent to <code>parent.replaceChild(newNode, oldNode)</code></p>
</div><pre class="source javascript"><strong class="lineNumber">137</strong>            next[3].replaceChild(next[2], next[1]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">138</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">139</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">140</strong>    opQueue = [];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">141</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">142</strong></pre></div>
<div class="line"><div class="doc"><p>A function to compare event handlers in <code>renderJDOM</code></p>
</div><pre class="source javascript"><strong class="lineNumber">144</strong>const diffEvents = (whole, sub, cb) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">145</strong>    for (const eventName of Object.keys(whole)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">146</strong>        const wholeEvents = arrayNormalize(whole[eventName]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">147</strong>        const subEvents = arrayNormalize(sub[eventName] || []);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">148</strong>        for (const handlerFn of wholeEvents) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">149</strong>            if (!subEvents.includes(handlerFn)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">150</strong>                cb(eventName, handlerFn);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">151</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">152</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">153</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">154</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">155</strong></pre></div>
<div class="line"><div class="doc"><p>Torus&#39;s virtual DOM rendering algorithm that manages all diffing, updating, and efficient DOM access. <code>renderJDOM</code> takes <code>node</code>, the previous root node; <code>previous</code>, the previous JDOM; and <code>next</code>, the new JDOM; and returns the new root node (potentially different from the old root node.) Whenever a component is rendered, it calls <code>renderJDOM</code>. This rendering algorithm is recursive into child nodes. Despite not touching the DOM, this is still one of the most expensive parts of rendering.</p>
</div><pre class="source javascript"><strong class="lineNumber">163</strong>const renderJDOM = (node, previous, next) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">164</strong></pre></div>
<div class="line"><div class="doc"><p>This queues up a node to be inserted into a new slot in the DOM tree. All queued replacements will flush to DOM at the end of the render pass, from <code>runDOMOperations</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">168</strong>    const replacePreviousNode = newNode =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">169</strong>        if (node &#38;&#38; node !== newNode) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">170</strong>            opQueue.push([OP_REPLACE, node, newNode]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">171</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">172</strong>        node = newNode;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">173</strong>    };</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">174</strong></pre></div>
<div class="line"><div class="doc"><p>We&#39;re rendering a new node in the render tree. Increment counter.</p>
</div><pre class="source javascript"><strong class="lineNumber">176</strong>    render_stack ++;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">177</strong></pre></div>
<div class="line"><div class="doc"><p>We only do diff operations if the previous and next items are not the same.</p>
</div><pre class="source javascript"><strong class="lineNumber">179</strong>    if (previous !== next) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>If we need to render a null (comment) node, create and insert a comment node. This might seem silly, but it keeps the DOM consistent between renders and makes diff simpler.</p>
</div><pre class="source javascript"><strong class="lineNumber">184</strong>        if (next === null) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">185</strong>            // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">186</strong>            if (node === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">187</strong>                render_debug('Add comment node');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">188</strong>            } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">189</strong>                render_debug(`Replace previous node &#60;${node.tagName}&#62; with comment node`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">190</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">191</strong>            // @enddebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">192</strong>            replacePreviousNode(tmpNode());</pre></div>
<div class="line"><div class="doc"><p>If we&#39;re rendering a string or raw number, convert it into a string and add a TextNode.</p>
</div><pre class="source javascript"><strong class="lineNumber">195</strong>        } else if (typeof next === 'string' || typeof next === 'number') {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">196</strong>            // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">197</strong>            if (node === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">198</strong>                render_debug(`Add text node "${next}"`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">199</strong>            } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">200</strong>                render_debug(`Replace previous node "${previous}" with text node "${next}"`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">201</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">202</strong>            // @enddebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">203</strong>            replacePreviousNode(document.createTextNode(next));</pre></div>
<div class="line"><div class="doc"><p>If we need to render a literal DOM Node, just replace the old node with the literal node.</p>
</div><pre class="source javascript"><strong class="lineNumber">206</strong>        } else if (next.nodeType !== undefined) { // check if next instanceof Node</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">207</strong>            // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">208</strong>            if (node === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">209</strong>                render_debug(`Add literal element &#60;${next.tagName.toLowerCase()}&#62;`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">210</strong>            } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">211</strong>                render_debug(`Replace literal element &#60;${previous.tagName.toLowerCase()}&#62; with literal element &#60;${next.tagName.toLowerCase()}&#62;`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">212</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">213</strong>            // @enddebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">214</strong>            replacePreviousNode(next);</pre></div>
<div class="line"><div class="doc"><p>If we&#39;re rendering an object literal, assume it&#39;s a serialized JDOM dictionary. This is the meat of the algorithm.</p>
</div><pre class="source javascript"><strong class="lineNumber">217</strong>        } else { // next is a non-null object</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">218</strong>            if (!isObject(previous) || (previous &#38;&#38; previous.nodeType !== undefined)) { // check if previous instanceof Node</pre></div>
<div class="line"><div class="doc"><p>If the previous JDOM doesn&#39;t exist or wasn&#39;t JDOM, we&#39;re adding a completely new node into the DOM. Stub an empty <code>previous</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">221</strong>                previous = {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">222</strong>                    tag: null,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">223</strong>                };</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">224</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">225</strong>            normalizeJDOM(previous);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">226</strong>            normalizeJDOM(next);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">227</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">228</strong>            // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">229</strong>            render_debug(`Render pass for &#60;${next.tag}&#62;:`, true);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">230</strong></pre></div>
<div class="line"><div class="doc"><p>If the tags differ, we assume the subtrees will be different as well and just start a completely new element. This is efficient in practice, reduces the time complexity of the algorithm, and an optimization shared with React&#39;s reconciler.</p>
</div><pre class="source javascript"><strong class="lineNumber">235</strong>            if (previous.tag !== next.tag || !node) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">236</strong>                if (node === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">237</strong>                    // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">238</strong>                    render_debug(`Add &#60;${next.tag}&#62;`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">239</strong>                } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">240</strong>                    // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">241</strong>                    render_debug(`Replace previous node &#60;${node.tagName}&#62; with &#60;${next.tag}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">242</strong>                    // new root element, so "reset" previous</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">243</strong>                    previous = {};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">244</strong>                    normalizeJDOM(previous);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">245</strong>                }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">246</strong>                replacePreviousNode(document.createElement(next.tag));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">247</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">248</strong></pre></div>
<div class="line"><div class="doc"><p>Compare and update attributes</p>
</div><pre class="source javascript"><strong class="lineNumber">250</strong>            for (const attrName of Object.keys(next.attrs)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">251</strong>                switch (attrName) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">252</strong>                    case 'class':</pre></div>
<div class="line"><div class="doc"><p>JDOM can pass classes as either a single string or an array of strings, so we need to check for either of those cases.</p>
</div><pre class="source javascript"><strong class="lineNumber">256</strong>                        const nextClass = next.attrs.class;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>Mutating <code>className</code> is faster than iterating through <code>classList</code> objects if there&#39;s only one batch operation for all class changes.</p>
</div><pre class="source javascript"><strong class="lineNumber">260</strong>                        if (Array.isArray(nextClass)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">261</strong>                            // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">262</strong>                            if (node.className !== nextClass.join(' ')) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">263</strong>                                render_debug(`Update class names for &#60;${next.tag}&#62; to "${nextClass.join(' ')}"`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">264</strong>                            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">265</strong>                            // @enddebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">266</strong>                            node.className = nextClass.join(' ');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">267</strong>                        } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">268</strong>                            // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">269</strong>                            if (node.className !== nextClass) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">270</strong>                                render_debug(`Update class name for &#60;${next.tag}&#62; to ${nextClass}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">271</strong>                            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">272</strong>                            // @enddebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">273</strong>                            node.className = nextClass;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">274</strong>                        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">275</strong>                        break;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">276</strong>                    case 'style':</pre></div>
<div class="line"><div class="doc"><p>JDOM takes style attributes as a dictionary rather than a string for API ergonomics, so we serialize it differently than other attributes.</p>
</div><pre class="source javascript"><strong class="lineNumber">280</strong>                        const prevStyle = previous.attrs.style || {};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">281</strong>                        const nextStyle = next.attrs.style;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">282</strong></pre></div>
<div class="line"><div class="doc"><p>When we iterate through the key/values of a flat object like this, you may be tempted to use <code>Object.entries()</code>. We use <code>Object.keys()</code> and lookups, which is less idiomatic, but fast. This results in a measurable performance bump.</p>
</div><pre class="source javascript"><strong class="lineNumber">286</strong>                        for (const styleKey of Object.keys(nextStyle)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">287</strong>                            if (nextStyle[styleKey] !== prevStyle[styleKey]) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">288</strong>                                // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">289</strong>                                render_debug(`Set &#60;${next.tag}&#62; style ${styleKey}: ${nextStyle[styleKey]}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">290</strong>                                node.style[styleKey] = nextStyle[styleKey];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">291</strong>                            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">292</strong>                        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">293</strong>                        for (const styleKey of Object.keys(prevStyle)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">294</strong>                            if (nextStyle[styleKey] === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">295</strong>                                // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">296</strong>                                render_debug(`Unsetting &#60;${next.tag}&#62; style ${styleKey}: ${prevStyle[styleKey]}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">297</strong>                                node.style[styleKey] = '';</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">298</strong>                            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">299</strong>                        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">300</strong>                        break;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">301</strong>                    default:</pre></div>
<div class="line"><div class="doc"><p>If an attribute is an IDL attribute, we set it through JavaScript properties on the HTML element and not <code>setAttribute()</code>. This is necessary for properties like <code>value</code> and <code>indeterminate</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">306</strong>                        if (HTML_IDL_ATTRIBUTES.includes(attrName)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">307</strong>                            // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">308</strong>                            render_debug(`Set &#60;${next.tag}&#62; property ${attrName} = ${next.attrs[attrName]}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">309</strong>                            node[attrName] = next.attrs[attrName];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">310</strong>                        } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">311</strong>                            if (next.attrs[attrName] !== previous.attrs[attrName]) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">312</strong>                                // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">313</strong>                                render_debug(`Set &#60;${next.tag}&#62; attribute "${attrName}" to "${next.attrs[attrName]}"`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">314</strong>                                node.setAttribute(attrName, next.attrs[attrName]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">315</strong>                            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">316</strong>                        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">317</strong>                        break;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">318</strong>                }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">319</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">320</strong>            }</pre></div>
<div class="line"><div class="doc"><p>For any attributes that were removed in the new JDOM, also attempt to remove them from the DOM.</p>
</div><pre class="source javascript"><strong class="lineNumber">323</strong>            for (const attrName of Object.keys(previous.attrs)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">324</strong>                if (next.attrs[attrName] === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">325</strong>                    if (HTML_IDL_ATTRIBUTES.includes(attrName)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">326</strong>                        // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">327</strong>                        render_debug(`Remove &#60;${next.tag} property ${attrName}`);</pre></div>
<div class="line"><div class="doc"><p><code>null</code> seems to be the default for most IDL attrs, but even this isn&#39;t entirely consistent. This seems like something we should fix as issues come up, not preemptively search for a cross-browser solution.</p>
</div><pre class="source javascript"><strong class="lineNumber">332</strong>                        node[attrName] = null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">333</strong>                    } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">334</strong>                        // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">335</strong>                        render_debug(`Remove &#60;${next.tag}&#62; attribute ${attrName}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">336</strong>                        node.removeAttribute(attrName);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">337</strong>                    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">338</strong>                }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">339</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">340</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">341</strong>            diffEvents(next.events, previous.events, (eventName, handlerFn) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">342</strong>                // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">343</strong>                render_debug(`Set new ${eventName} event listener on &#60;${next.tag}&#62;`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">344</strong>                node.addEventListener(eventName, handlerFn);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">345</strong>            });</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">346</strong>            diffEvents(previous.events, next.events, (eventName, handlerFn) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">347</strong>                // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">348</strong>                render_debug(`Remove ${eventName} event listener on &#60;${next.tag}&#62;`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">349</strong>                node.removeEventListener(eventName, handlerFn);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">350</strong>            });</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">351</strong></pre></div>
<div class="line"><div class="doc"><p>Render children recursively. These loops are also well optimized, since it&#39;s a hot patch of code at runtime. We memoize generated child nodes into this <code>previous._nodes</code> array so we don&#39;t have to perform expensive, DOM-touching operations during reconciliation to look up children of the current node in the next render pass. <code>nodeChildren</code> will be updated alongside enqueued DOM mutation operations.</p>
</div><pre class="source javascript"><strong class="lineNumber">358</strong>            const nodeChildren = previous._nodes || [];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">359</strong>            const prevChildren = previous.children;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">360</strong>            const nextChildren = next.children;</pre></div>
<div class="line"><div class="doc"><p>Memoize length lookups.</p>
</div><pre class="source javascript"><strong class="lineNumber">362</strong>            const prevLength = prevChildren.length;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">363</strong>            const nextLength = nextChildren.length;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">364</strong>            const minLength = prevLength &#60; nextLength ? prevLength : nextLength;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">365</strong>            if (nextLength &#62; 0 || prevLength &#62; 0) {</pre></div>
<div class="line"><div class="doc"><p>&quot;sync&quot; the common sections of the two children lists.</p>
</div><pre class="source javascript"><strong class="lineNumber">367</strong>                let i;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">368</strong>                for (i = 0; i &#60; minLength; i ++) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">369</strong>                    const newChild = renderJDOM(nodeChildren[i], prevChildren[i], nextChildren[i]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">370</strong>                    nodeChildren.splice(i, 1, newChild);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">371</strong>                }</pre></div>
<div class="line"><div class="doc"><p>If the new JDOM has more children than the old JDOM, we need to add the extra children.</p>
</div><pre class="source javascript"><strong class="lineNumber">374</strong>                if (prevLength &#60; nextLength) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">375</strong>                    while (i &#60; nextLength) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">376</strong>                        // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">377</strong>                        if (nextChildren[i].tagName) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">378</strong>                            render_debug(`Add child &#60;${nextChildren[i].tagName.toLowerCase()}&#62;`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">379</strong>                        } else if (nextChildren[i].tag) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">380</strong>                            render_debug(`Add child &#60;${nextChildren[i].tag}&#62;`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">381</strong>                        } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">382</strong>                            render_debug(`Add child "${nextChildren[i]}"`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">383</strong>                        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">384</strong>                        // @enddebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">385</strong>                        const newChild = renderJDOM(undefined, undefined, nextChildren[i]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">386</strong>                        opQueue.push([OP_APPEND, node, newChild]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">387</strong>                        nodeChildren.splice(i, 0, newChild);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">388</strong>                        i ++;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">389</strong>                    }</pre></div>
<div class="line"><div class="doc"><p>If the new JDOM has less than or equal number of children to the old JDOM, we&#39;ll remove any stragglers.</p>
</div><pre class="source javascript"><strong class="lineNumber">392</strong>                } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">393</strong>                    while (i &#60; prevLength) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">394</strong>                        // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">395</strong>                        if (prevChildren[i].tagName) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">396</strong>                            render_debug(`Remove child &#60;${prevChildren[i].tagName.toLowerCase()}&#62;`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">397</strong>                        } else if (prevChildren[i].tag) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">398</strong>                            render_debug(`Remove child &#60;${prevChildren[i].tag}&#62;`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">399</strong>                        } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">400</strong>                            render_debug(`Remove child "${prevChildren[i]}"`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">401</strong>                        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">402</strong>                        // @enddebug</pre></div>
<div class="line"><div class="doc"><p>If we need to remove a child element, removing it from the DOM immediately might lead to race conditions. instead, we add a placeholder and remove the placeholder at the end.</p>
</div><pre class="source javascript"><strong class="lineNumber">407</strong>                        opQueue.push([OP_REMOVE, node, nodeChildren[i]]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">408</strong>                        i ++;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">409</strong>                    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">410</strong>                    nodeChildren.splice(nextLength, prevLength - nextLength);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">411</strong>                }</pre></div>
<div class="line"><div class="doc"><p>Mount <code>nodeChildren</code> onto the up-to-date JDOM, so the next render pass can reference it.</p>
</div><pre class="source javascript"><strong class="lineNumber">414</strong>                next._nodes = nodeChildren;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">415</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">416</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">417</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">418</strong></pre></div>
<div class="line"><div class="doc"><p>We&#39;re done rendering the current node, so decrement the render stack counter.</p>
</div><pre class="source javascript"><strong class="lineNumber">421</strong>    render_stack --;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">422</strong></pre></div>
<div class="line"><div class="doc"><p>If we&#39;ve reached the top of the render tree, it&#39;s time to flush replaced nodes to the DOM before the next frame.</p>
</div><pre class="source javascript"><strong class="lineNumber">425</strong>    if (render_stack === 0) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p><code>runDOMOperations()</code> can also be called completely asynchronously with utilities like <code>requestIdleCallback</code>, <em>a la</em> Concurrent React, for better responsiveness on larger component trees. This requires a modification to Torus&#39;s architecture, so that each set of <code>DOMOperations</code> tasks in the <code>opQueue</code> from one component&#39;s render call are flushed to the DOM before the next component&#39;s <code>DOMOperations</code> begins, for consistency. This can be achieved with a nested queue layer on top of <code>opQueue</code>. Here, we omit concurrency support today because it&#39;s not a great necessity where Torus is used.</p>
</div><pre class="source javascript"><strong class="lineNumber">435</strong>        runDOMOperations();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">436</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">437</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">438</strong>    return node;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">439</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">440</strong></pre></div>
<div class="line"><div class="doc"><p>Shorthand function for the default, empty event object in <code>Component</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">442</strong>const emptyEvent = () =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">443</strong>    return {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">444</strong>        source: null,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">445</strong>        handler: () =&#62; {},</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">446</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">447</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">448</strong></pre></div>
<div class="line"><div class="doc"><p>Torus&#39;s Component class</p>
</div><pre class="source javascript"><strong class="lineNumber">450</strong>class Component {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">451</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">452</strong>    constructor(...args) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">453</strong>        this.jdom = undefined;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">454</strong>        this.node = undefined;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">455</strong>        this.event = emptyEvent();</pre></div>
<div class="line"><div class="doc"><p>We call init() before render, because it&#39;s a common pattern to set and initialize &quot;private&quot; fields in <code>this.init()</code> (at least before the ES-next private fields proposal becomes widely supported.) Frequently, rendering will require private values to be set correctly.</p>
</div><pre class="source javascript"><strong class="lineNumber">460</strong>        this.init(...args);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>After we run <code>#init()</code>, we want to make sure that every constructed component has a valid <code>#node</code> property. To be efficient, we only render to set <code>#node</code> if it isn&#39;t already set yet.</p>
</div><pre class="source javascript"><strong class="lineNumber">464</strong>        if (this.node === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">465</strong>            this.render();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">466</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">467</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">468</strong></pre></div>
<div class="line"><div class="doc"><p><code>Component.from()</code> allows us to transform a pure function that maps arguments to a JDOM tree, and promote it into a full-fledged <code>Component</code> class we can compose and use anywhere.</p>
</div><pre class="source javascript"><strong class="lineNumber">472</strong>    static from(fn) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">473</strong>        return class FunctionComponent extends Component {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">474</strong>            init(...args) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">475</strong>                this.args = args;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">476</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">477</strong>            compose() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">478</strong>                return fn(...this.args);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">479</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">480</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">481</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">482</strong></pre></div>
<div class="line"><div class="doc"><p>The default <code>Component#init()</code> is guaranteed to always be a no-op method</p>
</div><pre class="source javascript"><strong class="lineNumber">484</strong>    init() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">485</strong>        // should be overridden</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">486</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">487</strong></pre></div>
<div class="line"><div class="doc"><p>Components usually subscribe to events from a Record, either a view model or a model that maps to business logic. This is shorthand to access that.</p>
</div><pre class="source javascript"><strong class="lineNumber">490</strong>    get record() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">491</strong>        return this.event.source;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">492</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">493</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">494</strong>    bind(source, handler) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">495</strong>        this.unbind();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">496</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">497</strong>        if (source instanceof Evented) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">498</strong>            this.event = {source, handler};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">499</strong>            source.addHandler(handler);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">500</strong>        } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">501</strong>            throw new Error(`Tried to bind to ${source}, which is not an instance of Evented`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">502</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">503</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">504</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">505</strong>    unbind() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">506</strong>        if (this.record) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">507</strong>            this.record.removeHandler(this.event.handler);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">508</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">509</strong>        this.event = emptyEvent();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">510</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">511</strong></pre></div>
<div class="line"><div class="doc"><p>We use <code>#remove()</code> to prepare to remove the component from our application entirely. By default, it unsubscribes from all updates. However, the component is still in the render tree -- that&#39;s something for the user to decide when to hide.</p>
</div><pre class="source javascript"><strong class="lineNumber">516</strong>    remove() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">517</strong>        this.unbind();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">518</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">519</strong></pre></div>
<div class="line"><div class="doc"><p><code>#compose()</code> is our primary rendering API for components. By default, it renders an invisible comment node.</p>
</div><pre class="source javascript"><strong class="lineNumber">522</strong>    compose(data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">523</strong>        return null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">524</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">525</strong></pre></div>
<div class="line"><div class="doc"><p><code>#preprocess()</code> is an API on the component to allow us to extend <code>Component</code> to give it additional capabilities idiomatically. It consumes the result of <code>#compose()</code> and returns JDOM to be used to actually render the component. See <code>Styled()</code> for a usage example -- it fills similar use cases as React&#39;s render props or HOCs.</p>
</div><pre class="source javascript"><strong class="lineNumber">530</strong>    preprocess(jdom, data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">531</strong>        return jdom;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">532</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">533</strong></pre></div>
<div class="line"><div class="doc"><p><code>#render()</code> is called to actually render the component again to the DOM, and Torus assumes that it&#39;s called rarely, only when the component absolutely must update. This obviates the need for something like React&#39;s <code>shouldComponentUpdate</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">537</strong>    render(data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">538</strong>        // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">539</strong>        render_debug(`Render Component: ${this.constructor.name}`, true);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">540</strong>        data = data || (this.record &#38;&#38; this.record.summarize())</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">541</strong>        const jdom = this.preprocess(this.compose(data), data);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">542</strong>        try {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">543</strong>            this.node = renderJDOM(this.node, this.jdom, jdom);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">544</strong>        } catch (e) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">545</strong>            console.error('Error rendering updates', e);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">546</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">547</strong>        return this.jdom = jdom;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">548</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">549</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">550</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">551</strong></pre></div>
<div class="line"><div class="doc"><p>We keep track of unique class names already injected into the page&#39;s stylesheet, so we don&#39;t do redundant style reconciliation.</p>
</div><pre class="source javascript"><strong class="lineNumber">554</strong>const injectedClassNames = new Set();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">555</strong></pre></div>
<div class="line"><div class="doc"><p>Global pointer to the stylesheet on the page that Torus uses to insert new CSS rules. It&#39;s set the first time a styled component renders.</p>
</div><pre class="source javascript"><strong class="lineNumber">558</strong>let styledComponentSheet = null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">559</strong></pre></div>
<div class="line"><div class="doc"><p>Fast pure function to map a style rule to a very reasonably unique class name that won&#39;t conflict with other classes on the page.</p>
</div><pre class="source javascript"><strong class="lineNumber">562</strong>const generateUniqueClassName = stylesObject =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">563</strong>    // Modified from https://github.com/darkskyapp/string-hash/blob/master/index.js</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">564</strong>    const str = JSON.stringify(stylesObject);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">565</strong>    let i = str.length;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">566</strong>    let hash = 1989;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">567</strong>    while (i) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">568</strong>        hash = (hash * 13) ^ str.charCodeAt(--i);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">569</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">570</strong>    return '_torus' + (hash &#62;&#62;&#62; 0);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">571</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">572</strong></pre></div>
<div class="line"><div class="doc"><p>We have to construct lots of a{b} syntax in CSS, so here&#39;s a shorthand.</p>
</div><pre class="source javascript"><strong class="lineNumber">574</strong>const brace = (a, b) =&#62; a + '{' + b + '}';</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">575</strong></pre></div>
<div class="line"><div class="doc"><p>The meat of <code>Styled()</code>. This function maps an ergonomic, dictionary-based set of CSS declarations to an array of CSS rules that can be inserted onto the page stylesheet, and recursively resolves nested CSS, handles keyframes and media queries, and parses other SCSS-like things.</p>
</div><pre class="source javascript"><strong class="lineNumber">580</strong>const rulesFromStylesObject = (selector, stylesObject) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">581</strong>    let rules = [];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">582</strong>    let selfDeclarations = '';</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">583</strong>    for (const prop of Object.keys(stylesObject)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">584</strong>        const val = stylesObject[prop];</pre></div>
<div class="line"><div class="doc"><p>CSS declarations that start with &#39;@&#39; are globally namespaced (like @keyframes and @media), so we need to treat them differently.</p>
</div><pre class="source javascript"><strong class="lineNumber">587</strong>        if (prop[0] === '@') {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">588</strong>            if (prop.startsWith('@media')) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">589</strong>                rules.push(brace(prop, rulesFromStylesObject(selector, val).join('')));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">590</strong>            } else  { // @keyframes or @font-face</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">591</strong>                rules.push(brace(prop, rulesFromStylesObject('', val).join('')));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">592</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">593</strong>        } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">594</strong>            if (typeof val === 'object') {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">595</strong>                const commaSeparatedProps = prop.split(',');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">596</strong>                for (const p of commaSeparatedProps) {</pre></div>
<div class="line"><div class="doc"><p>SCSS-like syntax means we use &#39;&amp;&#39; to nest declarations about the parent selector.</p>
</div><pre class="source javascript"><strong class="lineNumber">599</strong>                    if (p.includes('&#38;')) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">600</strong>                        const fullSelector = p.replace(/&#38;/g, selector);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">601</strong>                        rules = rules.concat(rulesFromStylesObject(fullSelector, val));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">602</strong>                    } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">603</strong>                        rules = rules.concat(rulesFromStylesObject(selector + ' ' + p, val));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">604</strong>                    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">605</strong>                }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">606</strong>            } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">607</strong>                selfDeclarations += prop + ':' + val + ';';</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">608</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">609</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">610</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">611</strong>    if (selfDeclarations) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">612</strong>        rules.push(brace(selector, selfDeclarations));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">613</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">614</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">615</strong>    return rules;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">616</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">617</strong></pre></div>
<div class="line"><div class="doc"><p>Function called once to initialize a stylesheet for Torus to use on every subsequent style render.</p>
</div><pre class="source javascript"><strong class="lineNumber">620</strong>const initSheet = () =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">621</strong>    styleElement = document.createElement('style');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">622</strong>    styleElement.setAttribute('data-torus', '');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">623</strong>    document.head.appendChild(styleElement);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">624</strong>    styledComponentSheet = styleElement.sheet;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">625</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">626</strong></pre></div>
<div class="line"><div class="doc"><p>The preprocessor on <code>Styled()</code> components call this to make sure a given set of CSS rules for a component is inserted into the page stylesheet, but only once for a unique set of rules. We disambiguate by the class name, which is a hash of the CSS rules.</p>
</div><pre class="source javascript"><strong class="lineNumber">631</strong>const injectStylesOnce = stylesObject =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">632</strong>    const className = generateUniqueClassName(stylesObject);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">633</strong>    if (!injectedClassNames.has(className)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">634</strong>        if (!styledComponentSheet) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">635</strong>            initSheet();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">636</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">637</strong>        const rules = rulesFromStylesObject('.' + className, stylesObject);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">638</strong>        for (const rule of rules) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">639</strong>            // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">640</strong>            render_debug(`Add new CSS rule: ${rule}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">641</strong>            styledComponentSheet.insertRule(rule, styledComponentSheet.cssRules.length);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">642</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">643</strong>        injectedClassNames.add(className);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">644</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">645</strong>    return className;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">646</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">647</strong></pre></div>
<div class="line"><div class="doc"><p>Higher-order component to enable styling for any Component class.</p>
</div><pre class="source javascript"><strong class="lineNumber">649</strong>const Styled = Base =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">650</strong>    return class extends Base {</pre></div>
<div class="line"><div class="doc"><p>In a styled component, the <code>#styles()</code> method is passed in the same data as <code>#compose()</code>, and returns a JSON of nested CSS.</p>
</div><pre class="source javascript"><strong class="lineNumber">653</strong>        styles(data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">654</strong>            return {};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">655</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">656</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">657</strong>        preprocess(jdom, data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">658</strong>            if (isObject(jdom)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">659</strong>                jdom.attrs = jdom.attrs || {};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">660</strong>                jdom.attrs.class = arrayNormalize(jdom.attrs.class || []);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">661</strong>                jdom.attrs.class.push(injectStylesOnce(this.styles(data)));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">662</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">663</strong>            return jdom;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">664</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">665</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">666</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">667</strong></pre></div>
<div class="line"><div class="doc"><p>Provide a default, <code>StyledComponent</code> class</p>
</div><pre class="source javascript"><strong class="lineNumber">669</strong>const StyledComponent = Styled(Component);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">670</strong></pre></div>
<div class="line"><div class="doc"><p>Torus&#39;s generic List implementation, based on Stores. React and similar virtual-dom view libraries depend on <a href="https://reactjs.org/docs/reconciliation.html">key-based reconciliation</a> during render to efficiently render children of long lists. Torus doesn&#39;t (yet) have a key-aware reconciler in the diffing algorithm, but <code>List</code>&#39;s design obviates the need for keys. Rather than giving the renderer a flat virtual DOM tree to render, <code>List</code> instantiates each individual item component and hands them off to the renderer as full DOM Node elements, so each list item manages its own rendering, and the list component only worries about displaying the list wrapper and a flat list of children items.</p>
</div><pre class="source javascript"><strong class="lineNumber">680</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">681</strong>class List extends Component {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">682</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">683</strong>    get itemClass() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">684</strong>        return Component; // default value, should be overridden</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">685</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">686</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">687</strong>    init(store, ...itemData) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">688</strong>        this.store = store;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">689</strong>        this.items = new Map();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">690</strong>        this.filterFn = null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">691</strong>        this.itemData = itemData;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">692</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">693</strong>        this.bind(this.store, () =&#62; this.itemsChanged());</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">694</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">695</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">696</strong>    itemsChanged() {</pre></div>
<div class="line"><div class="doc"><p>For every record in the store, if it isn&#39;t already in <code>this.items</code>, add it and its view; if any were removed, also remove it from <code>this.items</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">700</strong>        const data = this.store.summarize();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">701</strong>        for (const record of this.items.keys()) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">702</strong>            if (!data.includes(record)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">703</strong>                this.items.get(record).remove();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">704</strong>                this.items.delete(record);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">705</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">706</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">707</strong>        for (const record of data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">708</strong>            if (!this.items.has(record)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">709</strong>                this.items.set(</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">710</strong>                    record,</pre></div>
<div class="line"><div class="doc"><p>We pass a callback that takes a record and removes it from the list&#39;s store. It&#39;s common in UIs for items to have a button that removes the item from the list, so this callback is passed to the item component constructor to facilitate that pattern.</p>
</div><pre class="source javascript"><strong class="lineNumber">715</strong>                    new this.itemClass(</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">716</strong>                        record,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">717</strong>                        () =&#62; this.store.remove(record),</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">718</strong>                        ...this.itemData</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">719</strong>                    )</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">720</strong>                );</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">721</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">722</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">723</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">724</strong>        let sorter = [...this.items.entries()];</pre></div>
<div class="line"><div class="doc"><p>Sort by the provided filter function if there is one</p>
</div><pre class="source javascript"><strong class="lineNumber">726</strong>        if (this.filterFn !== null) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">727</strong>            sorter = sorter.filter(item =&#62; this.filterFn(item[0]));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">728</strong>        }</pre></div>
<div class="line"><div class="doc"><p>Sort the list the way the associated Store is sorted.</p>
</div><pre class="source javascript"><strong class="lineNumber">730</strong>        sorter.sort((a, b) =&#62; data.indexOf(a[0]) - data.indexOf(b[0]));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">731</strong></pre></div>
<div class="line"><div class="doc"><p>Store the new items in a new (insertion-ordered) Map at this.items</p>
</div><pre class="source javascript"><strong class="lineNumber">733</strong>        this.items = new Map(sorter);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">734</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">735</strong>        this.render();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">736</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">737</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">738</strong>    filter(filterFn) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">739</strong>        this.filterFn = filterFn;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">740</strong>        this.itemsChanged();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">741</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">742</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">743</strong>    unfilter() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">744</strong>        this.filterFn = null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">745</strong>        this.itemsChanged();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">746</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">747</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">748</strong>    get components() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">749</strong>        return [...this.items.values()];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">750</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">751</strong></pre></div>
<div class="line"><div class="doc"><p><code>List#nodes</code> returns the HTML nodes for each of its item views, sorted in order. Designed to make writing <code>#compose()</code> easier.</p>
</div><pre class="source javascript"><strong class="lineNumber">754</strong>    get nodes() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">755</strong>        return this.components.map(item =&#62; item.node);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">756</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">757</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">758</strong>    remove() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">759</strong>        super.remove();</pre></div>
<div class="line"><div class="doc"><p>When we remove a list, we also want to call <code>remove()</code> on each child components.</p>
</div><pre class="source javascript"><strong class="lineNumber">762</strong>        for (const c of this.items.values()) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">763</strong>            c.remove();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">764</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">765</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">766</strong></pre></div>
<div class="line"><div class="doc"><p>By default, just render the children views in a <ul/></p>
</div><pre class="source javascript"><strong class="lineNumber">768</strong>    compose(data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">769</strong>        return {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">770</strong>            tag: 'ul',</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">771</strong>            children: this.nodes,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">772</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">773</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">774</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">775</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">776</strong></pre></div>
<div class="line"><div class="doc"><p>Higher-order component to create a list component for a given child item component.</p>
</div><pre class="source javascript"><strong class="lineNumber">779</strong>const ListOf = itemClass =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">780</strong>    return class extends List {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">781</strong>        get itemClass() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">782</strong>            return itemClass;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">783</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">784</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">785</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">786</strong></pre></div>
<div class="line"><div class="doc"><p>A base class for evented data stores. Not exposed to the public API, but all observables in Torus inherit from <code>Evented</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">789</strong>class Evented {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">790</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">791</strong>    constructor() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">792</strong>        this.eventTargets = new Set();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">793</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">794</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">795</strong>    summarize() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">796</strong>        throw new Error(`#summarize() not implemented in ${this.constructor.name}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">797</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">798</strong></pre></div>
<div class="line"><div class="doc"><p>Whenever something changes, we fire an event to all subscribed listeners, with a summary of its state.</p>
</div><pre class="source javascript"><strong class="lineNumber">801</strong>    emitEvent() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">802</strong>        const summary = this.summarize();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">803</strong>        for (const handler of this.eventTargets) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">804</strong>            handler(summary);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">805</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">806</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">807</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">808</strong>    addHandler(handler) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">809</strong>        this.eventTargets.add(handler);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">810</strong>        handler(this.summarize());</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">811</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">812</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">813</strong>    removeHandler(handler) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">814</strong>        this.eventTargets.delete(handler);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">815</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">816</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">817</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">818</strong></pre></div>
<div class="line"><div class="doc"><p><code>Record</code> is Torus&#39;s unit of individual data source, used for view models and Models from business logic.</p>
</div><pre class="source javascript"><strong class="lineNumber">821</strong>class Record extends Evented {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">822</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">823</strong>    constructor(id, data = {}) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">824</strong>        super();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">825</strong></pre></div>
<div class="line"><div class="doc"><p>We can create a Record by either passing in just the properties, or an ID and a dictionary of props. We disambiguate here.</p>
</div><pre class="source javascript"><strong class="lineNumber">828</strong>        if (isObject(id)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">829</strong>            data = id;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">830</strong>            id = null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">831</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">832</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">833</strong>        this.id = id;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">834</strong>        this.data = data;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">835</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">836</strong></pre></div>
<div class="line"><div class="doc"><p>Setter for properties</p>
</div><pre class="source javascript"><strong class="lineNumber">838</strong>    update(data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">839</strong>        Object.assign(this.data, data);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">840</strong>        this.emitEvent();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">841</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">842</strong></pre></div>
<div class="line"><div class="doc"><p>Getter</p>
</div><pre class="source javascript"><strong class="lineNumber">844</strong>    get(name) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">845</strong>        return this.data[name];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">846</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">847</strong></pre></div>
<div class="line"><div class="doc"><p>We summarize a Record by returning a dictionary of all of its properties and the ID</p>
</div><pre class="source javascript"><strong class="lineNumber">850</strong>    summarize() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">851</strong>        return Object.assign(</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">852</strong>            {},</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">853</strong>            this.data,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">854</strong>            {id: this.id}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">855</strong>        );</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">856</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">857</strong></pre></div>
<div class="line"><div class="doc"><p>The JSON-serialized version of a Record is the same as its summary, since it&#39;s a shallow data store with just plain properties.</p>
</div><pre class="source javascript"><strong class="lineNumber">860</strong>    serialize() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">861</strong>        return this.summarize();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">862</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">863</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">864</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">865</strong></pre></div>
<div class="line"><div class="doc"><p>A list of Records, represents a collection or a table</p>
</div><pre class="source javascript"><strong class="lineNumber">867</strong>class Store extends Evented {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">868</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">869</strong>    constructor(records = []) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">870</strong>        super();</pre></div>
<div class="line"><div class="doc"><p>Reset the store&#39;s contents with the given records</p>
</div><pre class="source javascript"><strong class="lineNumber">872</strong>        this.reset(records);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">873</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">874</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">875</strong>    get recordClass() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">876</strong>        return Record;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">877</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">878</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">879</strong>    get comparator() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">880</strong>        return null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">881</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">882</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">883</strong>    create(id, data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">884</strong>        this.add(new this.recordClass(id, data));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">885</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">886</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">887</strong>    add(record) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">888</strong>        this.records.add(record);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">889</strong>        this.emitEvent();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">890</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">891</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">892</strong>    remove(record) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">893</strong>        this.records.delete(record);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">894</strong>        this.emitEvent();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">895</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">896</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">897</strong>    reset(records) {</pre></div>
<div class="line"><div class="doc"><p>Internally, we represent the store as an unordered set. we only order by comparator when we summarize. This prevents us from having to perform sorting checks on every insert/update, and is efficient as long as we don&#39;t re-render excessively.</p>
</div><pre class="source javascript"><strong class="lineNumber">902</strong>        this.records = new Set(records);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">903</strong>        this.emitEvent();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">904</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">905</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">906</strong>    summarize() {</pre></div>
<div class="line"><div class="doc"><p>The summary of a store is defined functionally. We just sort the records in our store by the comparator (but we use a list of pairs of cached comparators and records to be fast.</p>
</div><pre class="source javascript"><strong class="lineNumber">910</strong>        return [...this.records].map(record =&#62; [</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">911</strong>            this.comparator ? this.comparator(record) : null,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">912</strong>            record,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">913</strong>        ]).sort((a, b) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">914</strong>            if (a[0] &#60; b[0]) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">915</strong>                return -1;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">916</strong>            } else if (a[0] &#62; b[0]) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">917</strong>                return 1;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">918</strong>            } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">919</strong>                return 0;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">920</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">921</strong>        }).map(o =&#62; o[1]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">922</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">923</strong></pre></div>
<div class="line"><div class="doc"><p>To serialize a store, we serialize each record and put them in a giant list.</p>
</div><pre class="source javascript"><strong class="lineNumber">926</strong>    serialize() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">927</strong>        return this.summarize().map(record =&#62; record.serialize());</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">928</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">929</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">930</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">931</strong></pre></div>
<div class="line"><div class="doc"><p>Higher-order component to create a Store for a given record class.</p>
</div><pre class="source javascript"><strong class="lineNumber">934</strong>const StoreOf = recordClass =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">935</strong>    return class extends Store {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">936</strong>        get recordClass() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">937</strong>            return recordClass;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">938</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">939</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">940</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">941</strong></pre></div>
<div class="line"><div class="doc"><p>Helper function for the router. It takes a route string that contains parameters like, <code>/path/:param1/path/:param2</code> and returns a regular expression to match that route and a list of params in that route.</p>
</div><pre class="source javascript"><strong class="lineNumber">946</strong>const routeStringToRegExp = route =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">947</strong>    let match;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">948</strong>    const paramNames = [];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">949</strong>    while (match !== null) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">950</strong>        match = (/:\w+/).exec(route);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">951</strong>        if (match) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">952</strong>            const paramName = match[0];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">953</strong>            paramNames.push(paramName.substr(1));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">954</strong>            route = route.replace(paramName, '(.*)');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">955</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">956</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">957</strong>    return [new RegExp(route), paramNames];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">958</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">959</strong></pre></div>
<div class="line"><div class="doc"><p>Front-end router. A routing component can bind to updates from the Router instead of a Record, and re-render different subviews when the routes change.</p>
</div><pre class="source javascript"><strong class="lineNumber">963</strong>class Router extends Evented {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">964</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">965</strong>    constructor(routes) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">966</strong>        super();</pre></div>
<div class="line"><div class="doc"><p>We parse the given dictionary of routes into three things: the name of the route, the route regular expression, and the list of params in that route.</p>
</div><pre class="source javascript"><strong class="lineNumber">970</strong>        this.routes = Object.entries(routes)</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">971</strong>            .map(([name, route]) =&#62; [name, ...routeStringToRegExp(route)]);</pre></div>
<div class="line"><div class="doc"><p>Last matched route&#39;s information is cached here</p>
</div><pre class="source javascript"><strong class="lineNumber">973</strong>        this.lastMatch = ['', null];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>Whenever the browser pops the history state (i.e. when the user goes back with the back button or forward with the forward button), we need to route again.</p>
</div><pre class="source javascript"><strong class="lineNumber">977</strong>        this._cb = () =&#62; this.route(location.pathname);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">978</strong>        window.addEventListener('popstate', this._cb);</pre></div>
<div class="line"><div class="doc"><p>Route the current URL, if it&#39;s already a deep link to a path.</p>
</div><pre class="source javascript"><strong class="lineNumber">980</strong>        this._cb();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">981</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">982</strong></pre></div>
<div class="line"><div class="doc"><p>The &quot;summary&quot; of this Evented (components can bind to this object) is the information about the last route.</p>
</div><pre class="source javascript"><strong class="lineNumber">985</strong>    summarize() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">986</strong>        return this.lastMatch;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">987</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">988</strong></pre></div>
<div class="line"><div class="doc"><p>Click events from links can call <code>this.go()</code> with the destination URL to trigger going to a new route without reloading the page.</p>
</div><pre class="source javascript"><strong class="lineNumber">991</strong>    go(destination) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">992</strong>        history.pushState(null, document.title, destination);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">993</strong>        this.route(destination);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">994</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">995</strong></pre></div>
<div class="line"><div class="doc"><p>Main procedure to reconcile which of the defined route the current location path matches, and dispatch the right event. Routes are checked in order of declaration.</p>
</div><pre class="source javascript"><strong class="lineNumber">999</strong>    route(path) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>Match destination against the route regular expressions</p>
</div><pre class="source javascript"><strong class="lineNumber">1001</strong>        for (const [name, routeRe, paramNames] of this.routes) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1002</strong>            const match = routeRe.exec(path);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1003</strong>            if (match !== null) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1004</strong>                const result = {};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1005</strong>                const paramValues = match.slice(1);</pre></div>
<div class="line"><div class="doc"><p>Given the matched values and parameter names, build a dictionary of params that components can use to re-render based on the route.</p>
</div><pre class="source javascript"><strong class="lineNumber">1009</strong>                paramNames.forEach((name, i) =&#62; result[name] = paramValues[i]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1010</strong>                this.lastMatch = [name, result];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1011</strong>                break;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1012</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1013</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1014</strong>        this.emitEvent();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1015</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1016</strong></pre></div>
<div class="line"><div class="doc"><p>When we don&#39;t want the router to work anymore / stop listening / be gc&#39;d, we can call <code>#remove()</code> to do just that.</p>
</div><pre class="source javascript"><strong class="lineNumber">1019</strong>    remove() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1020</strong>        window.removeEventListener('popstate', this._cb);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1021</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1022</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1023</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1024</strong></pre></div>
<div class="line"><div class="doc"><p>Torus exposes these public APIs</p>
</div><pre class="source javascript"><strong class="lineNumber">1026</strong>const exposedNames = {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p><code>renderJDOM</code> isn&#39;t designed to be a public API and the API might change, but it&#39;s exposed to make unit testing easier.</p>
</div><pre class="source javascript"><strong class="lineNumber">1029</strong>    renderJDOM,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1030</strong>    Component,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1031</strong>    Styled,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1032</strong>    StyledComponent,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1033</strong>    List,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1034</strong>    ListOf,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1035</strong>    Record,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1036</strong>    Store,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1037</strong>    StoreOf,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1038</strong>    Router,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1039</strong>}</pre></div>
<div class="line"><div class="doc"><p>If there is a global <code>window</code> object, bind API names to it.</p>
</div><pre class="source javascript"><strong class="lineNumber">1041</strong>if (typeof window === 'object') {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1042</strong>    for (const name of Object.keys(exposedNames)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1043</strong>        window[name] = exposedNames[name];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1044</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1045</strong>}</pre></div>
<div class="line"><div class="doc"><p>Export public APIs CommonJS-style</p>
</div><pre class="source javascript"><strong class="lineNumber">1047</strong>if (typeof module === 'object' &#38;&#38; typeof module.exports === 'object') {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1048</strong>    module.exports = exposedNames;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1049</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1050</strong></pre></div>
    </main>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/github-gist.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
    <script>
        for (const el of document.querySelectorAll('.line pre')) {
            hljs.highlightBlock(el);
        }
    </script>
</body>

</html>